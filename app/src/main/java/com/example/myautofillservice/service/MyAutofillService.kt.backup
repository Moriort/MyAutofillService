package com.example.myautofillservice.service

import android.app.assist.AssistStructure
import android.os.Build
import android.os.CancellationSignal
import android.service.autofill.*
import android.util.Log
import android.view.autofill.AutofillId
import android.view.autofill.AutofillValue
import android.widget.RemoteViews
import androidx.annotation.RequiresApi
import com.example.myautofillservice.data.Credential
import com.example.myautofillservice.data.CredentialDatabase
import com.example.myautofillservice.compatibility.BankCompatibilityManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@RequiresApi(Build.VERSION_CODES.O)
class MyAutofillService : AutofillService() {

    companion object {
        private const val TAG = "MyAutofillService"
    }

    override fun onFillRequest(
        request: FillRequest,
        cancellationSignal: CancellationSignal,
        callback: FillCallback
    ) {
        Log.d(TAG, "onFillRequest called")
        
        // Obtener la estructura de la actividad
        val structure = request.fillContexts.lastOrNull()?.structure
        if (structure == null) {
            Log.w(TAG, "No structure available")
            callback.onSuccess(null)
            return
        }

        // Identificar la p√°gina usando el sistema h√≠brido
        val pageInfo = com.example.myautofillservice.utils.PageIdentifier.identifyPage(structure)
        val webSiteManager = WebSiteManager(applicationContext)
        
        Log.d(TAG, "üîç Page identification results:")
        Log.d(TAG, "  URL: ${pageInfo.url}")
        Log.d(TAG, "  Domain: ${pageInfo.domain}")
        Log.d(TAG, "  Page ID: ${pageInfo.pageId}")
        Log.d(TAG, "  Title: ${pageInfo.title}")
        
        // DIAGN√ìSTICO: Verificar por qu√© el dominio no se detecta
        if (pageInfo.domain.isNullOrBlank()) {
            Log.w(TAG, "‚ö†Ô∏è DOMAIN DETECTION FAILED - Using fallback system")
            Log.w(TAG, "This will cause credentials to be saved with page signature instead of real domain")
        } else {
            Log.d(TAG, "‚úÖ Real domain detected successfully: ${pageInfo.domain}")
        }
        
        // Analizar los campos de entrada
        val autofillFields = parseStructure(structure)
        
        if (autofillFields.isEmpty()) {
            Log.d(TAG, "No autofill fields found")
            callback.onSuccess(null)
            return
        }

        // Buscar credenciales usando el sistema h√≠brido
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // Priorizar el dominio web real si est√° disponible
                val currentDomain = if (!pageInfo.domain.isNullOrBlank()) {
                    Log.d(TAG, "Using real web domain: ${pageInfo.domain}")
                    pageInfo.domain!!
                } else {
                    // Fallback al sistema h√≠brido si no hay dominio web
                    val siteIdentification = webSiteManager.identifyOrCreateWebSite(pageInfo)
                    when (siteIdentification) {
                        is WebSiteIdentification.ExactMatch -> {
                            Log.d(TAG, "Using exact match: ${siteIdentification.webSite.name}")
                            siteIdentification.webSite.pageId
                        }
                        is WebSiteIdentification.NewSite -> {
                            Log.d(TAG, "Using new site: ${siteIdentification.webSite.name}")
                            siteIdentification.webSite.pageId
                        }
                        is WebSiteIdentification.SimilarSites -> {
                            // Por ahora, usar el primer sitio similar
                            // TODO: Implementar UI para que el usuario elija
                            Log.d(TAG, "Found similar sites, using first: ${siteIdentification.similarSites.first().name}")
                            siteIdentification.similarSites.first().pageId
                        }
                    }
                }
                
                val database = CredentialDatabase.getDatabase(applicationContext)
                val credentials = database.credentialDao().getCredentialsForDomain(currentDomain)
                
                Log.d(TAG, "Searching for credentials with domain: '$currentDomain'")
                Log.d(TAG, "Found ${credentials.size} credentials for domain: $currentDomain")
                
                // Debug: Mostrar todas las credenciales en la base de datos
                val allCredentials = database.credentialDao().getAllCredentials()
                Log.d(TAG, "Total credentials in database: ${allCredentials.size}")
                allCredentials.forEach { cred ->
                    Log.d(TAG, "  - Domain: '${cred.domain}', User: ${cred.username}, Title: ${cred.title}")
                }
                
                // Crear respuesta con credenciales reales o datos de ejemplo
                val fillResponse = if (credentials.isNotEmpty()) {
                    Log.d(TAG, "Using real credentials for response")
                    createFillResponseWithCredentials(autofillFields, credentials)
                } else {
                    Log.d(TAG, "No credentials found, using fallback response")
                    createFallbackFillResponse(autofillFields)
                }
                
                callback.onSuccess(fillResponse)
            } catch (e: Exception) {
                Log.e(TAG, "Error retrieving credentials", e)
                callback.onSuccess(createFallbackFillResponse(autofillFields))
            }
        }
    }

    override fun onSaveRequest(request: SaveRequest, callback: SaveCallback) {
        Log.d(TAG, "üî• onSaveRequest called - SAVE DIALOG TRIGGERED!")
        Log.d(TAG, "SaveRequest details:")
        Log.d(TAG, "  - FillContexts: ${request.fillContexts.size}")
        Log.d(TAG, "  - ClientState: ${request.clientState}")
        
        val structure = request.fillContexts.lastOrNull()?.structure
        if (structure == null) {
            Log.w(TAG, "No structure available for saving")
            callback.onSuccess()
            return
        }
        
        // Identificar la p√°gina usando el sistema h√≠brido (igual que en onFillRequest)
        val pageInfo = com.example.myautofillservice.utils.PageIdentifier.identifyPage(structure)
        val webSiteManager = WebSiteManager(applicationContext)
        
        Log.d(TAG, "Saving credentials for page:")
        Log.d(TAG, "  URL: ${pageInfo.url}")
        Log.d(TAG, "  Domain: ${pageInfo.domain}")
        Log.d(TAG, "  Page ID: ${pageInfo.pageId}")
        Log.d(TAG, "  Title: ${pageInfo.title}")
        
        // Extraer credenciales de los campos
        val credentials = extractCredentialsFromStructure(structure)
        
        if (credentials.isNotEmpty()) {
            // Guardar credenciales usando el sistema h√≠brido
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    // Priorizar el dominio web real si est√° disponible
                    val currentDomain = if (!pageInfo.domain.isNullOrBlank()) {
                        Log.d(TAG, "Saving to real web domain: ${pageInfo.domain}")
                        pageInfo.domain!!
                    } else {
                        // Fallback al sistema h√≠brido si no hay dominio web
                        val siteIdentification = webSiteManager.identifyOrCreateWebSite(pageInfo)
                        when (siteIdentification) {
                            is WebSiteIdentification.ExactMatch -> {
                                Log.d(TAG, "Saving to exact match: ${siteIdentification.webSite.name}")
                                siteIdentification.webSite.pageId
                            }
                            is WebSiteIdentification.NewSite -> {
                                Log.d(TAG, "Saving to new site: ${siteIdentification.webSite.name}")
                                siteIdentification.webSite.pageId
                            }
                            is WebSiteIdentification.SimilarSites -> {
                                // Por ahora, usar el primer sitio similar
                                Log.d(TAG, "Saving to similar site: ${siteIdentification.similarSites.first().name}")
                                siteIdentification.similarSites.first().pageId
                            }
                        }
                    }
                    
                    val database = CredentialDatabase.getDatabase(applicationContext)
                    val dao = database.credentialDao()
                    
                    credentials.forEach { (username, password) ->
                        // Verificar si ya existe una credencial para este dominio y usuario
                        val existingCredential = dao.findExistingCredential(currentDomain, username)
                        
                        if (existingCredential != null) {
                            // Solo actualizar si la contrase√±a es diferente
                            if (existingCredential.password != password) {
                                val updatedCredential = existingCredential.copy(
                                    password = password,
                                    url = pageInfo.url ?: existingCredential.url,
                                    lastUsed = System.currentTimeMillis()
                                )
                                dao.updateCredential(updatedCredential)
                                Log.d(TAG, "Updated credential with new password for $username at $currentDomain")
                            } else {
                                // Solo actualizar el √∫ltimo uso
                                dao.updateLastUsed(existingCredential.id)
                                Log.d(TAG, "Updated last used time for $username at $currentDomain")
                            }
                        } else {
                            // Crear nueva credencial
                            val webSiteName = if (!pageInfo.domain.isNullOrBlank()) {
                                // Si usamos dominio web real, usar el t√≠tulo de la p√°gina o el dominio
                                pageInfo.title.takeIf { !it.isNullOrBlank() } ?: pageInfo.domain
                            } else {
                                // Si usamos sistema h√≠brido, obtener el nombre del sitio web
                                val siteIdentification = webSiteManager.identifyOrCreateWebSite(pageInfo)
                                when (siteIdentification) {
                                    is WebSiteIdentification.ExactMatch -> siteIdentification.webSite.name
                                    is WebSiteIdentification.NewSite -> siteIdentification.webSite.name
                                    is WebSiteIdentification.SimilarSites -> siteIdentification.similarSites.first().name
                                }
                            }
                            
                            val newCredential = Credential(
                                domain = currentDomain,
                                url = pageInfo.url ?: "https://$currentDomain",
                                username = username,
                                password = password,
                                title = webSiteName
                            )
                            dao.insertCredential(newCredential)
                            Log.d(TAG, "Saved new credential for $username at $currentDomain")
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error saving credentials", e)
                }
            }
        }
        
        callback.onSuccess()
    }

    private fun parseStructure(structure: AssistStructure): List<AutofillField> {
        val fields = mutableListOf<AutofillField>()
        
        for (i in 0 until structure.windowNodeCount) {
            val windowNode = structure.getWindowNodeAt(i)
            parseNode(windowNode.rootViewNode, fields)
        }
        
        // NUEVO: Aplicar mejoras de compatibilidad bancaria
        val pageInfo = com.example.myautofillservice.utils.PageIdentifier.identifyPage(structure)
        if (!pageInfo.domain.isNullOrBlank() && BankCompatibilityManager.isChileanBank(pageInfo.domain)) {
            Log.d(TAG, "üè¶ Applying Chilean bank compatibility for: ${pageInfo.domain}")
            return BankCompatibilityManager.enhanceFieldDetection(pageInfo.domain, fields)
        }
        
        return fields
    }

    private fun parseNode(node: AssistStructure.ViewNode, fields: MutableList<AutofillField>) {
        val autofillId = node.autofillId
        
        // Log informaci√≥n del nodo para debugging
        Log.d(TAG, "Analyzing node: ${node.className}")
        Log.d(TAG, "  AutofillId: $autofillId")
        Log.d(TAG, "  Text: ${node.text}")
        Log.d(TAG, "  Hints: ${node.autofillHints?.joinToString()}")
        Log.d(TAG, "  InputType: ${node.inputType}")
        Log.d(TAG, "  HtmlInfo: ${node.htmlInfo}")
        Log.d(TAG, "  IdEntry: ${node.idEntry}")
        
        if (autofillId != null && isAutofillableField(node)) {
            val hint = detectFieldType(node)
            Log.d(TAG, "Found autofillable field with detected hint: $hint")
            
            fields.add(AutofillField(
                autofillId = autofillId,
                hint = hint,
                text = node.text?.toString()
            ))
        }
        
        // Recursivamente analizar nodos hijos
        for (i in 0 until node.childCount) {
            parseNode(node.getChildAt(i), fields)
        }
    }
    
    private fun isAutofillableField(node: AssistStructure.ViewNode): Boolean {
        // Verificar si tiene hints expl√≠citos
        if (!node.autofillHints.isNullOrEmpty()) {
            Log.d(TAG, "Field has explicit hints: ${node.autofillHints?.joinToString()}")
            return true
        }
        
        // Verificar si es un campo de entrada de texto (Android nativo)
        val className = node.className?.toString()?.lowercase(java.util.Locale.getDefault())
        if (className?.contains("edittext") == true || 
            className?.contains("textinputedittext") == true ||
            className?.contains("autocompletetextview") == true) {
            Log.d(TAG, "Field detected by className: $className")
            return true
        }
        
        // Para campos web, verificar informaci√≥n HTML (MEJORADO)
        val htmlInfo = node.htmlInfo
        if (htmlInfo != null) {
            val tag = htmlInfo.tag?.lowercase(java.util.Locale.getDefault())
            val type = htmlInfo.attributes?.find { it.first == "type" }?.second?.lowercase(java.util.Locale.getDefault())
            val name = htmlInfo.attributes?.find { it.first == "name" }?.second?.lowercase(java.util.Locale.getDefault())
            val id = htmlInfo.attributes?.find { it.first == "id" }?.second?.lowercase(java.util.Locale.getDefault())
            val placeholder = htmlInfo.attributes?.find { it.first == "placeholder" }?.second?.lowercase(java.util.Locale.getDefault())
            
            // Campos de entrada HTML (EXPANDIDO)
            if (tag == "input") {
                when (type) {
                    "text", "email", "password", "tel", "number", 
                    "search", "url", "hidden" -> {
                        Log.d(TAG, "Field detected by HTML input type: $type")
                        return true
                    }
                    null -> {
                        // Si no tiene tipo espec√≠fico, verificar por otros atributos
                        if (name != null || id != null || placeholder != null) {
                            Log.d(TAG, "Field detected by HTML input without type but with attributes")
                            return true
                        }
                    }
                }
            }
            
            // Tambi√©n considerar textarea y select
            if (tag == "textarea" || tag == "select") {
                Log.d(TAG, "Field detected by HTML tag: $tag")
                return true
            }
        }
        
        // Verificar por inputType (MEJORADO)
        val inputType = node.inputType
        if (inputType != 0) {
            // Tipos de entrada m√°s completos
            val validInputTypes = listOf(
                0x00000001, // TYPE_CLASS_TEXT
                0x00000002, // TYPE_CLASS_NUMBER
                0x00000003, // TYPE_CLASS_PHONE
                0x00000021, // TYPE_TEXT_VARIATION_EMAIL_ADDRESS
                0x00000081, // TYPE_TEXT_VARIATION_PASSWORD
                0x00000091, // TYPE_TEXT_VARIATION_VISIBLE_PASSWORD
                0x000000b1, // TYPE_TEXT_VARIATION_WEB_PASSWORD
                0x000000c1, // TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS
                0x00000012, // TYPE_NUMBER_VARIATION_PASSWORD
                0x00000020, // TYPE_CLASS_DATETIME
                0x00000004  // TYPE_CLASS_DATETIME
            )
            
            if (validInputTypes.any { (inputType and 0x0000ffff) == it || (inputType and it) != 0 }) {
                Log.d(TAG, "Field detected by inputType: ${String.format("0x%08x", inputType)}")
                return true
            }
        }
        
        // Verificar por caracter√≠sticas del nodo (NUEVO)
        if (node.isFocusable && node.isEnabled) {
            // Si el nodo es enfocable y habilitado, podr√≠a ser un campo de entrada
            val text = node.text?.toString()
            val hint = node.hint
            val contentDescription = node.contentDescription?.toString()
            
            // Buscar indicadores de que es un campo de entrada
            val fieldIndicators = listOf(
                "rut", "usuario", "contrase√±a", "password", "email", "correo",
                "login", "user", "pass", "clave", "cedula", "documento",
                "telefono", "phone", "celular", "movil", "numero", "number"
            )
            
            listOf(text, hint, contentDescription).forEach { str ->
                str?.lowercase()?.let { lowerStr ->
                    if (fieldIndicators.any { lowerStr.contains(it) }) {
                        Log.d(TAG, "Field detected by content indicators: $str")
                        return true
                    }
                }
            }
        }
        
        // Verificar si est√° dentro de un formulario o modal (NUEVO)
        if (isWithinForm(node) || isWithinModal(node)) {
            // Si est√° dentro de un formulario o modal y es enfocable, probablemente es un campo
            if (node.isFocusable && node.isEnabled) {
                Log.d(TAG, "Field detected within form/modal context")
                return true
            }
        }
        
        return false
    }
    
    private fun detectFieldType(node: AssistStructure.ViewNode): String {
        // Primero verificar hints expl√≠citos
        val hints = node.autofillHints
        if (!hints.isNullOrEmpty()) {
            return hints[0]
        }
        
        // Detectar por informaci√≥n HTML (MEJORADO)
        val htmlInfo = node.htmlInfo
        if (htmlInfo != null) {
            val type = htmlInfo.attributes?.find { it.first == "type" }?.second?.lowercase(java.util.Locale.getDefault())
            val name = htmlInfo.attributes?.find { it.first == "name" }?.second?.lowercase(java.util.Locale.getDefault())
            val id = htmlInfo.attributes?.find { it.first == "id" }?.second?.lowercase(java.util.Locale.getDefault())
            val placeholder = htmlInfo.attributes?.find { it.first == "placeholder" }?.second?.lowercase(java.util.Locale.getDefault())
            
            // Detectar por tipo HTML
            when (type) {
                "email" -> return "emailAddress"
                "password" -> return "password"
                "tel" -> return "phone"
                "number" -> {
                    // Para campos num√©ricos, verificar si es RUT, c√©dula, etc.
                    listOf(name, id, placeholder).forEach { attr ->
                        attr?.let {
                            when {
                                it.contains("rut") || it.contains("cedula") || it.contains("documento") -> return "username"
                                it.contains("phone") || it.contains("telefono") || it.contains("celular") -> return "phone"
                            }
                        }
                    }
                    return "username" // Por defecto para campos num√©ricos
                }
            }
            
            // Detectar por nombre, ID o placeholder (EXPANDIDO)
            listOf(name, id, placeholder).forEach { attr ->
                attr?.let {
                    when {
                        it.contains("email") || it.contains("mail") || it.contains("correo") -> return "emailAddress"
                        it.contains("user") || it.contains("login") || it.contains("usuario") -> return "username"
                        it.contains("pass") || it.contains("contrase√±a") || it.contains("clave") -> return "password"
                        it.contains("phone") || it.contains("tel") || it.contains("telefono") || it.contains("celular") -> return "phone"
                        it.contains("rut") || it.contains("cedula") || it.contains("documento") || it.contains("dni") -> return "username"
                        it.contains("name") || it.contains("nombre") && !it.contains("user") -> return "name"
                    }
                }
            }
        }
        
        // Detectar por inputType (MEJORADO)
        val inputType = node.inputType
        when {
            (inputType and 0x00000021) != 0 -> return "emailAddress" // EMAIL_ADDRESS
            (inputType and 0x00000081) != 0 -> return "password"    // PASSWORD
            (inputType and 0x000000b1) != 0 -> return "password"    // WEB_PASSWORD
            (inputType and 0x000000c1) != 0 -> return "emailAddress" // WEB_EMAIL_ADDRESS
            (inputType and 0x00000002) != 0 -> return "username"    // NUMBER (para RUT, c√©dulas, etc.)
            (inputType and 0x00000003) != 0 -> return "phone"       // PHONE
        }
        
        // Detectar por texto del campo, hint o descripci√≥n (EXPANDIDO)
        val text = node.text?.toString()?.lowercase(java.util.Locale.getDefault())
        val hint = node.hint?.lowercase(java.util.Locale.getDefault())
        val contentDescription = node.contentDescription?.toString()?.lowercase(java.util.Locale.getDefault())
        
        listOf(text, hint, contentDescription).forEach { str ->
            str?.let {
                when {
                    it.contains("email") || it.contains("correo") || it.contains("mail") -> return "emailAddress"
                    it.contains("user") || it.contains("usuario") || it.contains("login") -> return "username"
                    it.contains("pass") || it.contains("contrase√±a") || it.contains("clave") -> return "password"
                    it.contains("phone") || it.contains("tel√©fono") || it.contains("telefono") || it.contains("celular") -> return "phone"
                    it.contains("rut") || it.contains("cedula") || it.contains("documento") || it.contains("dni") -> return "username"
                    it.contains("name") || it.contains("nombre") -> return "name"
                }
            }
        }
        
        // Detectar por contexto del campo (NUEVO)
        val fieldContext = getFieldContext(node)
        when {
            fieldContext.contains("login") || fieldContext.contains("signin") -> return "username"
            fieldContext.contains("password") || fieldContext.contains("contrase√±a") -> return "password"
            fieldContext.contains("email") || fieldContext.contains("correo") -> return "emailAddress"
        }
        
        // Por defecto, asumir que es un campo de texto gen√©rico
        return "username"
    }
    
    private fun getFieldContext(node: AssistStructure.ViewNode): String {
        // Recopilar texto del contexto alrededor del campo
        val context = mutableListOf<String>()
        
        // Agregar texto de labels cercanos, placeholders, etc.
        node.text?.toString()?.let { context.add(it) }
        node.hint?.let { context.add(it) }
        node.contentDescription?.toString()?.let { context.add(it) }
        
        // TODO: Agregar l√≥gica para buscar en nodos hermanos y padres
        
        return context.joinToString(" ").lowercase(java.util.Locale.getDefault())
    }
    
    private fun isWithinForm(node: AssistStructure.ViewNode): Boolean {
        // Verificar si el nodo est√° dentro de un formulario
        var parent = node
        var depth = 0
        
        // Buscar hasta 10 niveles hacia arriba
        while (depth < 10) {
            val className = parent.className?.toString()?.lowercase()
            val idEntry = parent.idEntry?.lowercase()
            
            // Indicadores de formulario
            if (className?.contains("form") == true ||
                idEntry?.contains("form") == true ||
                idEntry?.contains("login") == true ||
                idEntry?.contains("signin") == true ||
                idEntry?.contains("register") == true ||
                idEntry?.contains("signup") == true) {
                return true
            }
            
            // Verificar HTML
            parent.htmlInfo?.let { htmlInfo ->
                if (htmlInfo.tag?.lowercase() == "form") {
                    return true
                }
            }
            
            depth++
            // TODO: Implementar navegaci√≥n hacia el padre
            break // Por ahora, solo verificar el nodo actual
        }
        
        return false
    }
    
    private fun isWithinModal(node: AssistStructure.ViewNode): Boolean {
        // Verificar si el nodo est√° dentro de un modal o overlay
        var parent = node
        var depth = 0
        
        // Buscar hasta 10 niveles hacia arriba
        while (depth < 10) {
            val className = parent.className?.toString()?.lowercase()
            val idEntry = parent.idEntry?.lowercase()
            
            // Indicadores de modal/overlay
            if (className?.contains("modal") == true ||
                className?.contains("dialog") == true ||
                className?.contains("overlay") == true ||
                className?.contains("popup") == true ||
                idEntry?.contains("modal") == true ||
                idEntry?.contains("dialog") == true ||
                idEntry?.contains("overlay") == true ||
                idEntry?.contains("popup") == true) {
                return true
            }
            
            depth++
            // TODO: Implementar navegaci√≥n hacia el padre
            break // Por ahora, solo verificar el nodo actual
        }
        
        return false
    }

    private fun createFillResponse(fields: List<AutofillField>): FillResponse {
        val responseBuilder = FillResponse.Builder()
        
        // Crear datasets con datos de ejemplo
        val datasets = createSampleDatasets(fields)
        datasets.forEach { dataset ->
            responseBuilder.addDataset(dataset)
        }
        
        return responseBuilder.build()
    }

    private fun createSampleDatasets(fields: List<AutofillField>): List<Dataset> {
        val datasets = mutableListOf<Dataset>()
        
        // Solo crear datasets si hay campos v√°lidos
        if (fields.isEmpty()) {
            Log.w(TAG, "No fields available for sample datasets")
            return datasets
        }
        
        // Detectar si hay campos de banco (hints "off" o "new-password")
        val hasBankFields = fields.any { it.hint == "off" || it.hint == "new-password" }
        
        // Dataset de ejemplo 1
        val dataset1Builder = Dataset.Builder()
        val presentation1 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        
        var hasValidFields1 = false
        fields.forEach { field ->
            val value = if (hasBankFields) {
                // Datasets para bancos chilenos
                presentation1.setTextViewText(android.R.id.text1, "RUT de Ejemplo 1")
                when (field.hint) {
                    "username", "emailAddress" -> "12345678-9"
                    "password" -> "MiClave123"
                    "off" -> "12345678-9"
                    "new-password" -> "MiClave123"
                    else -> ""
                }
            } else {
                // Datasets est√°ndar
                presentation1.setTextViewText(android.R.id.text1, "Usuario de prueba 1")
                when (field.hint) {
                    "username", "emailAddress" -> "usuario1@ejemplo.com"
                    "password" -> "password123"
                    "name" -> "Juan P√©rez"
                    "phone" -> "+1234567890"
                    else -> ""
                }
            }
            
            if (value.isNotEmpty()) {
                dataset1Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation1
                )
                hasValidFields1 = true
            }
        }
        
        if (hasValidFields1) {
            datasets.add(dataset1Builder.build())
            Log.d(TAG, if (hasBankFields) "Added Chilean bank dataset 1" else "Added standard dataset 1")
        }
        
        // Dataset de ejemplo 2
        val dataset2Builder = Dataset.Builder()
        val presentation2 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        
        var hasValidFields2 = false
        fields.forEach { field ->
            val value = if (hasBankFields) {
                // Datasets para bancos chilenos
                presentation2.setTextViewText(android.R.id.text1, "RUT de Ejemplo 2")
                when (field.hint) {
                    "username", "emailAddress" -> "98765432-1"
                    "password" -> "ClaveSegura456"
                    "off" -> "98765432-1"
                    "new-password" -> "ClaveSegura456"
                    else -> ""
                }
            } else {
                // Datasets est√°ndar
                presentation2.setTextViewText(android.R.id.text1, "Usuario de prueba 2")
                when (field.hint) {
                    "username", "emailAddress" -> "usuario2@ejemplo.com"
                    "password" -> "mypassword456"
                    "name" -> "Mar√≠a Garc√≠a"
                    "phone" -> "+0987654321"
                    else -> ""
                }
            }
            
            if (value.isNotEmpty()) {
                dataset2Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation2
                )
                hasValidFields2 = true
            }
        }
        
        if (hasValidFields2) {
            datasets.add(dataset2Builder.build())
            Log.d(TAG, if (hasBankFields) "Added Chilean bank dataset 2" else "Added standard dataset 2")
        }
        
        return datasets
    }
    
    private fun createSampleDatasetsWithContext(fields: List<AutofillField>, domain: String?): List<Dataset> {
        val datasets = mutableListOf<Dataset>()
        
        // Solo crear datasets si hay campos v√°lidos
        if (fields.isEmpty()) {
            Log.w(TAG, "No fields available for sample datasets")
            return datasets
        }
        
        // NUEVO: Detectar si es un banco chileno para crear datasets espec√≠ficos
        val isChileanBank = !domain.isNullOrBlank() && BankCompatibilityManager.isChileanBank(domain)
        
        if (isChileanBank) {
            Log.d(TAG, "üè¶ Creating Chilean bank sample datasets")
            return createChileanBankDatasets(fields)
        } else {
            Log.d(TAG, "üåê Creating standard sample datasets")
            return createStandardDatasets(fields)
        }
    }
    
    private fun createChileanBankDatasets(fields: List<AutofillField>): List<Dataset> {
        val datasets = mutableListOf<Dataset>()
        
        // Dataset de ejemplo 1 - Banco chileno
        val dataset1Builder = Dataset.Builder()
        val presentation1 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation1.setTextViewText(android.R.id.text1, "RUT de Ejemplo 1")
        
        var hasValidFields1 = false
        fields.forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "12345678-9"
                "password" -> "MiClave123"
                "off" -> "12345678-9"
                "new-password" -> "MiClave123"
                else -> ""
            }
            
            if (value.isNotEmpty()) {
                dataset1Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation1
                )
                hasValidFields1 = true
            }
        }
        
        if (hasValidFields1) {
            datasets.add(dataset1Builder.build())
            Log.d(TAG, "Added Chilean bank dataset 1")
        }
        
        // Dataset de ejemplo 2 - Banco chileno
        val dataset2Builder = Dataset.Builder()
        val presentation2 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation2.setTextViewText(android.R.id.text1, "RUT de Ejemplo 2")
        
        var hasValidFields2 = false
        fields.forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "98765432-1"
                "password" -> "ClaveSegura456"
                "off" -> "98765432-1"
                "new-password" -> "ClaveSegura456"
                else -> ""
            }
            
            if (value.isNotEmpty()) {
                dataset2Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation2
                )
                hasValidFields2 = true
            }
        }
        
        if (hasValidFields2) {
            datasets.add(dataset2Builder.build())
            Log.d(TAG, "Added Chilean bank dataset 2")
        }
        
        return datasets
    }
    
    private fun createStandardDatasets(fields: List<AutofillField>): List<Dataset> {
        val datasets = mutableListOf<Dataset>()
        
        // Dataset de ejemplo 1 - Est√°ndar
        val dataset1Builder = Dataset.Builder()
        val presentation1 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation1.setTextViewText(android.R.id.text1, "Usuario de prueba 1")
        
        var hasValidFields1 = false
        fields.forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "usuario1@ejemplo.com"
                "password" -> "password123"
                "name" -> "Juan P√©rez"
                "phone" -> "+1234567890"
                else -> ""
            }
            
            if (value.isNotEmpty()) {
                dataset1Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation1
                )
                hasValidFields1 = true
            }
        }
        
        if (hasValidFields1) {
            datasets.add(dataset1Builder.build())
            Log.d(TAG, "Added standard dataset 1")
        }
        
        // Dataset de ejemplo 2 - Est√°ndar
        val dataset2Builder = Dataset.Builder()
        val presentation2 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation2.setTextViewText(android.R.id.text1, "Usuario de prueba 2")
        
        var hasValidFields2 = false
        fields.forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "usuario2@ejemplo.com"
                "password" -> "mypassword456"
                "name" -> "Mar√≠a Garc√≠a"
                "phone" -> "+0987654321"
                else -> ""
            }
            
            if (value.isNotEmpty()) {
                dataset2Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation2
                )
                hasValidFields2 = true
            }
        }
        
        if (hasValidFields2) {
            datasets.add(dataset2Builder.build())
            Log.d(TAG, "Added standard dataset 2")
        }
        
        return datasets
    }
        
        // Dataset de ejemplo 2 - Mejorado para bancos
        val dataset2Builder = Dataset.Builder()
        val presentation2 = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation2.setTextViewText(android.R.id.text1, "RUT de Ejemplo 2")
        
        var hasValidFields2 = false
        fields.forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "98765432-1"  // Otro RUT chileno
                "password" -> "ClaveSegura456"
                "name" -> "Mar√≠a Garc√≠a"
                "phone" -> "+56987654321"  // Formato chileno
                "off" -> "98765432-1"  // Para campos con hint "off" (bancos)
                "new-password" -> "ClaveSegura456"  // Para campos con hint "new-password"
                else -> ""
            }
            
            if (value.isNotEmpty()) {
                dataset2Builder.setValue(
                    field.autofillId,
                    AutofillValue.forText(value),
                    presentation2
                )
                hasValidFields2 = true
            }
        }
        
        if (hasValidFields2) {
            datasets.add(dataset2Builder.build())
            Log.d(TAG, "Added sample dataset 2 (Chilean format)")
        }
        
        return datasets
    }

    private fun logStructure(structure: AssistStructure) {
        Log.d(TAG, "=== Structure Analysis ===")
        for (i in 0 until structure.windowNodeCount) {
            val windowNode = structure.getWindowNodeAt(i)
            logNode(windowNode.rootViewNode, 0)
        }
    }

    private fun logNode(node: AssistStructure.ViewNode, depth: Int) {
        val indent = "  ".repeat(depth)
        Log.d(TAG, "${indent}Node: ${node.className}")
        Log.d(TAG, "${indent}  Text: ${node.text}")
        Log.d(TAG, "${indent}  Hints: ${node.autofillHints?.joinToString()}")
        Log.d(TAG, "${indent}  AutofillId: ${node.autofillId}")
        
        for (i in 0 until node.childCount) {
            logNode(node.getChildAt(i), depth + 1)
        }
    }

    private fun createFillResponseWithCredentials(
        fields: List<AutofillField>, 
        credentials: List<Credential>
    ): FillResponse {
        val responseBuilder = FillResponse.Builder()
        
        // Crear un dataset para cada credencial guardada
        credentials.forEach { credential ->
            val datasetBuilder = Dataset.Builder()
            val presentation = RemoteViews(packageName, android.R.layout.simple_list_item_1)
            presentation.setTextViewText(android.R.id.text1, "${credential.username} - ${credential.title}")
            
            var hasValidFields = false
            
            fields.forEach { field ->
                val value = when (field.hint) {
                    "username", "emailAddress" -> credential.username
                    "password" -> credential.password
                    else -> ""
                }
                
                if (value.isNotEmpty()) {
                    datasetBuilder.setValue(
                        field.autofillId,
                        AutofillValue.forText(value),
                        presentation
                    )
                    hasValidFields = true
                }
            }
            
            // Solo agregar el dataset si tiene al menos un campo v√°lido
            if (hasValidFields) {
                responseBuilder.addDataset(datasetBuilder.build())
                Log.d(TAG, "Added dataset for credential: ${credential.username}")
            } else {
                Log.w(TAG, "Skipped dataset for credential ${credential.username} - no valid fields")
            }
        }
        
        // SIEMPRE configurar SaveInfo para que ofrezca guardar credenciales
        configureSaveInfo(responseBuilder, fields)
        
        return responseBuilder.build()
    }
    
    private fun createFallbackFillResponse(fields: List<AutofillField>): FillResponse {
        val responseBuilder = FillResponse.Builder()
        
        // Crear datasets con datos de ejemplo cuando no hay credenciales guardadas
        val datasets = createSampleDatasets(fields)
        datasets.forEach { dataset ->
            responseBuilder.addDataset(dataset)
        }
        
        // SIEMPRE configurar SaveInfo para que ofrezca guardar credenciales
        configureSaveInfo(responseBuilder, fields)
        
        // Si no hay datasets ni SaveInfo, crear un dataset m√≠nimo para evitar FillResponse vac√≠o
        if (datasets.isEmpty() && fields.isNotEmpty()) {
            Log.w(TAG, "Creating minimal dataset to avoid empty FillResponse")
            val minimalDataset = createMinimalDataset(fields)
            if (minimalDataset != null) {
                responseBuilder.addDataset(minimalDataset)
            }
        }
        
        return responseBuilder.build()
    }
    
    private fun configureSaveInfo(responseBuilder: FillResponse.Builder, fields: List<AutofillField>) {
        Log.d(TAG, "=== Configuring SaveInfo ===")
        Log.d(TAG, "Total fields available: ${fields.size}")
        
        // Log todos los campos para debugging
        fields.forEachIndexed { index, field ->
            Log.d(TAG, "Field $index: hint='${field.hint}', text='${field.text}', id=${field.autofillId}")
        }
        
        // Identificar campos de usuario y contrase√±a con criterios m√°s amplios
        val usernameFields = fields.filter { field ->
            field.hint == "username" || 
            field.hint == "emailAddress" || 
            field.hint == "name" ||
            field.hint == "phone" ||
            field.hint.contains("user", ignoreCase = true) ||
            field.hint.contains("email", ignoreCase = true)
        }.map { it.autofillId }
        
        val passwordFields = fields.filter { field ->
            field.hint == "password" ||
            field.hint.contains("pass", ignoreCase = true) ||
            field.hint.contains("clave", ignoreCase = true)
        }.map { it.autofillId }
        
        Log.d(TAG, "Username fields found: ${usernameFields.size}")
        Log.d(TAG, "Password fields found: ${passwordFields.size}")
        
        // SIMPLIFICADO: Solo usar campos de contrase√±a para SaveInfo
        val saveFields = if (passwordFields.isNotEmpty()) {
            Log.d(TAG, "Using password fields for SaveInfo")
            passwordFields.toTypedArray()
        } else if (fields.isNotEmpty()) {
            Log.d(TAG, "Using all fields as fallback for SaveInfo")
            fields.map { it.autofillId }.toTypedArray()
        } else {
            Log.w(TAG, "No fields available for SaveInfo")
            emptyArray()
        }
        
        if (saveFields.isNotEmpty()) {
            try {
                // Determinar el tipo de datos a guardar
                val saveDataType = when {
                    passwordFields.isNotEmpty() && usernameFields.isNotEmpty() -> 
                        SaveInfo.SAVE_DATA_TYPE_USERNAME or SaveInfo.SAVE_DATA_TYPE_PASSWORD
                    passwordFields.isNotEmpty() -> 
                        SaveInfo.SAVE_DATA_TYPE_PASSWORD
                    usernameFields.isNotEmpty() -> 
                        SaveInfo.SAVE_DATA_TYPE_USERNAME
                    else -> 
                        SaveInfo.SAVE_DATA_TYPE_GENERIC
                }
                
                val saveInfoBuilder = SaveInfo.Builder(saveDataType, saveFields)
                
                // Configurar flags m√°s simples para que funcione
                saveInfoBuilder.setFlags(SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE)
                
                // Configurar descripci√≥n para el di√°logo (opcional pero √∫til)
                try {
                    saveInfoBuilder.setDescription("Guardar credenciales para este sitio")
                } catch (e: Exception) {
                    Log.w(TAG, "Could not set SaveInfo description", e)
                }
                
                // Configurar SaveInfo
                val saveInfo = saveInfoBuilder.build()
                responseBuilder.setSaveInfo(saveInfo)
                
                Log.d(TAG, "‚úÖ SaveInfo configured successfully!")
                Log.d(TAG, "  - Fields: ${saveFields.size}")
                Log.d(TAG, "  - Data type: $saveDataType")
                Log.d(TAG, "  - Flags: ${SaveInfo.FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE}")
                
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error configuring SaveInfo", e)
                
                // Fallback: configuraci√≥n m√≠nima
                try {
                    val minimalSaveInfo = SaveInfo.Builder(
                        SaveInfo.SAVE_DATA_TYPE_GENERIC,
                        saveFields
                    ).build()
                    responseBuilder.setSaveInfo(minimalSaveInfo)
                    Log.d(TAG, "‚úÖ Fallback SaveInfo configured")
                } catch (fallbackError: Exception) {
                    Log.e(TAG, "‚ùå Even fallback SaveInfo failed", fallbackError)
                }
            }
        } else {
            Log.w(TAG, "‚ùå No fields available for SaveInfo configuration")
        }
        
        Log.d(TAG, "=== SaveInfo configuration complete ===")
    }
    
    private fun extractCredentialsFromStructure(structure: AssistStructure): List<Pair<String, String>> {
        val credentials = mutableListOf<Pair<String, String>>()
        val fieldValues = mutableMapOf<String, String>()
        
        // Extraer valores de todos los campos
        for (i in 0 until structure.windowNodeCount) {
            val windowNode = structure.getWindowNodeAt(i)
            extractFieldValues(windowNode.rootViewNode, fieldValues)
        }
        
        Log.d(TAG, "Extracted field values: $fieldValues")
        
        // NUEVO: Detectar si es un banco chileno para manejo especial
        val pageInfo = com.example.myautofillservice.utils.PageIdentifier.identifyPage(structure)
        val isChileanBank = !pageInfo.domain.isNullOrBlank() && BankCompatibilityManager.isChileanBank(pageInfo.domain)
        
        if (isChileanBank) {
            Log.d(TAG, "üè¶ Processing Chilean bank credentials extraction")
            
            // Para bancos chilenos: buscar campos espec√≠ficos
            val rutValue = fieldValues["off"] ?: fieldValues["username"] ?: ""
            val claveValue = fieldValues["new-password"] ?: fieldValues["password"] ?: ""
            
            if (rutValue.isNotBlank() && claveValue.isNotBlank()) {
                Log.d(TAG, "üè¶ Found Chilean bank credentials: RUT=$rutValue, Clave=***")
                credentials.add(Pair(rutValue, claveValue))
            }
        } else {
            Log.d(TAG, "üåê Processing standard credentials extraction")
            
            // Para sitios normales: buscar combinaciones est√°ndar
            val userFields = fieldValues.filter { (key, _) ->
                key.contains("username") || key.contains("email") || key.contains("user") || key.contains("login")
            }
            
            val passwordFields = fieldValues.filter { (key, _) ->
                key.contains("password") || key.contains("pass")
            }
            
            // Crear pares de credenciales
            userFields.forEach { (_, username) ->
                passwordFields.forEach { (_, password) ->
                    if (username.isNotBlank() && password.isNotBlank()) {
                        credentials.add(Pair(username, password))
                    }
                }
            }
        }
        
        return credentials.distinctBy { it.first } // Evitar duplicados por usuario
    }
    
    private fun extractFieldValues(node: AssistStructure.ViewNode, fieldValues: MutableMap<String, String>) {
        val autofillId = node.autofillId
        
        if (autofillId != null && isAutofillableField(node)) {
            val fieldType = detectFieldType(node)
            
            // Intentar extraer el valor de m√∫ltiples fuentes
            var value = ""
            
            // 1. Primero intentar autofillValue (m√°s confiable)
            node.autofillValue?.let { autofillValue ->
                when {
                    autofillValue.isText -> value = autofillValue.textValue?.toString() ?: ""
                    autofillValue.isList -> {
                        // Para campos de lista/select
                        val listValue = autofillValue.listValue
                        if (listValue >= 0) {
                            value = listValue.toString()
                        }
                    }
                }
            }
            
            // 2. Si no hay autofillValue, intentar con el texto del nodo
            if (value.isBlank()) {
                node.text?.toString()?.let { nodeText ->
                    // Solo usar el texto si parece ser un valor ingresado (no un placeholder)
                    if (nodeText.isNotBlank() && !isPlaceholderText(nodeText, node)) {
                        value = nodeText
                        Log.d(TAG, "Using node text as value for $fieldType: $value")
                    }
                }
            }
            
            // 3. Para campos de contrase√±a, a veces el valor est√° oculto
            if (value.isBlank() && fieldType == "password") {
                // Intentar detectar si hay una contrase√±a ingresada
                val hint = node.hint
                val contentDesc = node.contentDescription?.toString()
                
                // Si el hint cambi√≥ o hay indicadores de que se ingres√≥ algo
                if (hint != null && hint.isNotBlank() && !hint.equals("password", true) && 
                    !hint.equals("contrase√±a", true) && !hint.equals("clave", true)) {
                    // El hint podr√≠a contener el valor (en algunos casos)
                    value = hint
                    Log.d(TAG, "Using hint as password value for $fieldType")
                } else if (node.isFocused || hasPasswordIndicators(node)) {
                    // Si el campo est√° enfocado o tiene indicadores de contrase√±a ingresada
                    value = "***" // Placeholder para indicar que hay una contrase√±a
                    Log.d(TAG, "Detected password field with hidden value for $fieldType")
                }
            }
            
            if (value.isNotBlank() && value != "***") {
                fieldValues[fieldType] = value
                Log.d(TAG, "Extracted value for $fieldType: $value")
            } else if (value == "***") {
                // Para contrase√±as ocultas, necesitamos una estrategia diferente
                Log.d(TAG, "Password field detected but value is hidden for $fieldType")
                // TODO: Implementar extracci√≥n de contrase√±as ocultas si es necesario
            } else {
                Log.d(TAG, "No value found for field $fieldType")
            }
        }
        
        // Recursivamente extraer de nodos hijos
        for (i in 0 until node.childCount) {
            extractFieldValues(node.getChildAt(i), fieldValues)
        }
    }
    
    private fun isPlaceholderText(text: String, node: AssistStructure.ViewNode): Boolean {
        val lowerText = text.lowercase()
        
        // Textos que probablemente son placeholders
        val placeholderIndicators = listOf(
            "ingrese", "enter", "escriba", "digite", "ejemplo", "example",
            "usuario", "username", "email", "correo", "contrase√±a", "password",
            "clave", "rut", "cedula", "documento", "telefono", "phone"
        )
        
        // Si el texto es muy corto o coincide con placeholders comunes
        if (text.length < 3 || placeholderIndicators.any { lowerText.contains(it) }) {
            return true
        }
        
        // Si coincide con el hint del nodo, probablemente es un placeholder
        node.hint?.let { hint ->
            if (text.equals(hint, ignoreCase = true)) {
                return true
            }
        }
        
        return false
    }
    
    private fun hasPasswordIndicators(node: AssistStructure.ViewNode): Boolean {
        // Verificar si hay indicadores de que se ingres√≥ una contrase√±a
        val inputType = node.inputType
        
        // Si es un campo de contrase√±a y est√° habilitado/enfocable
        if ((inputType and 0x00000081) != 0 || (inputType and 0x000000b1) != 0) {
            return node.isEnabled && node.isFocusable
        }
        
        // Verificar por HTML
        node.htmlInfo?.let { htmlInfo ->
            val type = htmlInfo.attributes?.find { it.first == "type" }?.second?.lowercase()
            if (type == "password") {
                return true
            }
        }
        
        return false
    }

    private fun createMinimalDataset(fields: List<AutofillField>): Dataset? {
        if (fields.isEmpty()) return null
        
        val datasetBuilder = Dataset.Builder()
        val presentation = RemoteViews(packageName, android.R.layout.simple_list_item_1)
        presentation.setTextViewText(android.R.id.text1, "Datos de ejemplo")
        
        var hasValidFields = false
        
        // Usar el primer campo disponible con un valor gen√©rico
        fields.take(1).forEach { field ->
            val value = when (field.hint) {
                "username", "emailAddress" -> "ejemplo@correo.com"
                "password" -> "ejemplo123"
                else -> "ejemplo"
            }
            
            datasetBuilder.setValue(
                field.autofillId,
                AutofillValue.forText(value),
                presentation
            )
            hasValidFields = true
        }
        
        return if (hasValidFields) {
            Log.d(TAG, "Created minimal dataset")
            datasetBuilder.build()
        } else {
            null
        }
    }

    data class AutofillField(
        val autofillId: AutofillId,
        val hint: String,
        val text: String?
    )
}